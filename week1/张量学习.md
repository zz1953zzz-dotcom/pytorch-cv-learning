#张量表示一个由数值组成的数组，这个数组可能有多个维度。 
#具有一个轴的张量对应数学上的向量（vector）； 具有两个轴的张量对应数学上的矩阵（matrix）； 
#具有两个轴以上的张量没有特殊的数学名称。
improt torch
x = torch.arange(12)    #创建一个行向量x，包含从0开始的前12个整数。
x.shape                 #访问张量(沿每个轴的长度)的形状
x.numel()               #张量中元素的总数
x.reshape(3,4)          #改变张量的形状而不改变元素数量和元素值     x.reshape(3,4) = x.reshape(3,-1) = x.reshape(-1,4)
torch.zeros((2,3,4))    #全为0
torch.one((2,3,4))      #全为1
torch.randn(3,4)        #每个元素都从均值为0、标准差为1的标准高斯分布（正态分布）中随机采样
torch.tensor([[2, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])
#还可以通过提供包含数值的Python列表（或嵌套列表），来为所需张量中的每个元素赋予确定值。 
#在这里，最外层的列表对应于轴0(行)，内层的列表对应于轴1(列)。

#对于任意具有相同形状的张量， 常见的标准算术运算符（+、-、*、/和**）都可以被升级为按元素运算。

X = torch.arange(12, dtype=torch.float32).reshape((3,4))
Y = torch.tensor([[2.0, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])
torch.cat((X, Y), dim=0), torch.cat((X, Y), dim=1)
#第一个输出张量的轴-0长度(6),是两个输入张量轴-0长度的总和(3+3);
#第二个输出张量的轴-1长度(8),是两个输入张量轴-1长度的总和(4+4)。
X == Y      #判断对于每个位置，X和Y的值是否相等
X.sum()     #对张量中所有元素求和

#广播机制
a = torch.arange(3).reshape((3, 1))
b = torch.arange(2).reshape((1, 2))
a, b
a + b
#由于a和b分别是3 * 1和1 * 2矩阵，如果让它们相加，它们的形状不匹配。 
#我们将两个矩阵广播为一个更大的3 * 2矩阵，如下所示：矩阵a将复制列，矩阵b将复制行，然后再按元素相加。
#能否广播：右对齐后相应维度满足其一即可（1）两元素相等；（2）某一维度一个张量有，一个张量没有；（3）某一维度两个张量都有，且其中一方为1

#索引和切片
X[-1], X[1:3]   #与任何Python数组一样：第一个元素的索引是0，最后一个元素索引是-1； 
                #可以指定范围以包含第一个元素和最后一个之前的元素。
X[1, 2] = 100   #除读取外，还可以通过指定索引来将元素写入矩阵。
#同时改变某几行(某几列)的值：
X[0:2, :] = 12

X += Y  or X[:] = X + Y     #这两个方法可以执行原地操作，节约内存

A = X.numpy()       #将深度学习定义的张量转换为Numpy张量
B = torch.tensor(A) #将Numpy张量转换成深度学习定义的张量

#Pytorch张量 -> numpy数组       .numpy()
#pandas DataFrame -> numpy数组  .to_numpy()
#numpy数组 -> Pytorch张量       torch.tensor()或torch.from_numpy()